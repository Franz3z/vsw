<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Team Collaboration Space</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="{{ url_for('static', filename='bundle.js') }}"></script>
    <script src="https://download.agora.io/sdk/release/AgoraRTC_N.js"></script>
</head>
<body>
    <div class="container">
        <!-- LEFT PANEL: Navigation & Controls -->
        <div class="left-panel">
            <div class="buttons">
                <a href="{{ url_for('dashboard', username=username) }}" class="styled-button">‚Üê</a>
            </div>

            <div class="chatbox">
                <div class="chatbox-header">
                    <span>Chat</span>
                    <button id="whiteboardToggleBtn">Show Whiteboard</button>
                </div>
                <div class="messages" id="messagesContainer"></div>
                <div class="input-container">
                    <textarea id="messageInput" placeholder="Type your message..." rows="2"></textarea>
                    <button class="send-button" onclick="sendMessage()">Send</button>
                </div>
            </div>

            <div class="voice-call-container">
                <h4>Voice Call</h4>
                <button id="joinBtn">Join Call</button>
                <button id="leaveBtn" disabled>Leave Call</button>
            </div>
        </div>

        <!-- RIGHT PANEL: Task Management -->
        <div class="right-panel" id="taskPanel">
            <button class="panel-toggle" id="taskPanelToggle">‚â°</button>
            <div class="task-panel-content">
                <h3>Group Tasks</h3>
                <!-- Task section for completed tasks -->
                <div class="task-section">
                    <div class="collapsible">‚úÖ Done</div>
                    <ul id="done-tasks">
                        <!-- Tasks will be populated by JavaScript -->
                    </ul>
                </div>
                <!-- Task section for tasks this week -->
                <div class="task-section">
                    <div class="collapsible">üéØ To Be Done This Week</div>
                    <ul id="this-week-tasks">
                        <!-- Tasks will be populated by JavaScript -->
                    </ul>
                </div>
                <!-- Task section for tasks next week -->
                <div class="task-section">
                    <div class="collapsible">üóìÔ∏è Tasks Next Week</div>
                    <ul id="next-week-tasks">
                        <!-- Tasks will be populated by JavaScript -->
                    </ul>
                </div>
            </div>
        </div>

        <!-- Modals for Whiteboard, etc. -->
        <div id="whiteboardModal" class="modal-backdrop" style="display: none;">
            <div class="modal-content">
                <button class="modal-close-btn" id="closeWhiteboardBtn">√ó</button>
                <h3>Whiteboard</h3>
                <div id="whiteboard-container">
                    <canvas id="whiteboardCanvas" width="800" height="600"></canvas>
                </div>
                <div class="whiteboard-controls">
                    <button id="clearWhiteboardBtn">Clear Whiteboard</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Agora.io configuration (replace with your actual APP_ID)
        const APP_ID = "8f0029e7fd2047339fe6822ab5b59abd";
        const CHANNEL = "{{ group_id }}";
        const UID = Math.floor(Math.random() * 10000);
        let client = null; // Agora client for voice calls
        let localTrack = null; // Agora local audio track
    </script>
    <script>
        // Mesfuncsage handling
        function fetchMessages() {
            console.log("Fetching messages...");
            fetch(`/get_messages/${groupId}`)
                .then(response => response.json())
                .then(data => {
                    const messagesContainer = document.getElementById('messagesContainer');
                    messagesContainer.innerHTML = '';
                    data.messages.forEach(msg => {
                        const msgElement = document.createElement('p');
                        msgElement.textContent = `${msg.timestamp} - ${msg.sender}: ${msg.message}`;
                        messagesContainer.appendChild(msgElement);
                    });
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                })
                .catch(error => console.error('Error fetching messages:', error));
        }

        function sendMessage() {
            // Get the message text from the input field and remove leading/trailing whitespace
            const text = document.getElementById('messageInput').value.trim();

            // If the message is empty after trimming, do nothing
            if (!text) {
                return;
            }

            // Send a POST request to the server to save the message
            fetch(`/send_message/${groupId}`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        sender: username,
                        text
                    })
                })
                .then(res => res.json()) // Parse the JSON response from the server
                .then(data => {
                    // If the message was sent successfully
                    if (data.success) {
                        // Clear the message input field
                        document.getElementById('messageInput').value = "";
                        // Immediately fetch the messages to show the new one
                        fetchMessages();
                    }
                })
                .catch(error => {
                    // Log any errors that occur during the fetch
                    console.error('Error sending message:', error);
                });
        }
    </script>
    <script>
        // Voice call functions
        function joinVoiceCall() {
            client = AgoraRTC.createClient({
                mode: "rtc",
                codec: "vp8"
            });

            client.on("user-published", async (user, mediaType) => {
                await client.subscribe(user, mediaType);
                if (mediaType === "audio") {
                    user.audioTrack.play();
                }
            });

            client.on("user-unpublished", () => {});

            client.join(APP_ID, CHANNEL, null, UID)
                .then(() => {
                    return AgoraRTC.createMicrophoneAudioTrack();
                })
                .then(track => {
                    localTrack = track;
                    client.publish([localTrack]);
                    document.getElementById("joinBtn").disabled = true;
                    document.getElementById("leaveBtn").disabled = false;
                })
                .catch(err => {
                    console.error("Failed to join channel:", err);
                    alert("Error joining the call: " + err.message);
                });
        }

        function leaveVoiceCall() {
            if (localTrack) {
                localTrack.stop();
                localTrack.close();
            }

            if (client) {
                client.leave()
                    .then(() => {
                        document.getElementById("joinBtn").disabled = false;
                        document.getElementById("leaveBtn").disabled = true;
                    });
            }
        }
    </script>
    <script>
        // UI functions for whiteboard and task panel
        function openWhiteboard() {
            document.getElementById('whiteboardModal').style.display = 'flex';
        }

        function closeWhiteboard() {
            document.getElementById('whiteboardModal').style.display = 'none';
        }

        function clearWhiteboard() {
            // Implementation would be in whiteboard.js
            console.log("Whiteboard cleared");
        }

        /**
         * Toggles the visibility of the task panel.
         */
        function toggleTaskPanel() {
            const panel = document.getElementById('taskPanel');
            panel.classList.toggle('collapsed');
            document.getElementById('taskPanelToggle').textContent = panel.classList.contains('collapsed') ? '‚â°' : '√ó';
        }
    
        /**
         * Toggles the visibility of a collapsible section.
         */
        function toggleCollapsible(element) {
            element.classList.toggle('collapsed');
            const ul = element.nextElementSibling;
            ul.style.display = ul.style.display === 'none' ? 'block' : 'none';
        }
    </script>
    <script>
        // Task rendering and fetching functions
        // Ensure username and groupId are available from the Jinja context
        const username = "{{ username }}";
        const groupId = "{{ group_id }}";
        
        /**
         * Fetches all tasks from the backend, filters them by user and status,
         * and dynamically updates the task lists in the DOM.
         */
        function fetchTasks() {
            console.log("Fetching all tasks...");
            // Now fetching from the /get_all_tasks endpoint
            fetch(`/get_all_tasks/${groupId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // The backend returns a single 'tasks' array, so we must filter on the frontend
                        const allTasks = data.tasks || [];

                        const completed_tasks = [];
                        const tasks_this_week = [];
                        const tasks_next_week = [];

                        // Filter and categorize tasks for the current user
                        allTasks.forEach(task => {
                            if (task.assigned_to === username || task.assigned_type === 'everyone') {
                                if (task.completed) {
                                    completed_tasks.push(task);
                                } else if (task.week_category === 'This Week') {
                                    tasks_this_week.push(task);
                                } else if (task.week_category === 'Next Week') {
                                    tasks_next_week.push(task);
                                }
                            }
                        });

                        // Function to render a list of tasks
                        const renderTasks = (containerId, tasks, noTasksMessage) => {
                            const container = document.getElementById(containerId);
                            container.innerHTML = ''; // Clear existing tasks

                            if (tasks.length === 0) {
                                const noTasksLi = document.createElement('li');
                                noTasksLi.className = 'no-tasks';
                                noTasksLi.textContent = noTasksMessage;
                                container.appendChild(noTasksLi);
                            } else {
                                tasks.forEach(task => {
                                    const taskElement = document.createElement('li');
                                    taskElement.className = 'task-card';

                                    // Inner HTML for the task card, including progress forms if applicable
                                    let taskInnerHtml = `
                                        <div class="task-title">${task.task_name}</div>
                                        <div class="task-meta">
                                            <div class="assignee-info">Assigned to: ${task.assigned_to}</div>
                                            <span class="priority-tag priority-${task.priority.toLowerCase()}">${task.priority}</span>
                                        </div>
                                        <div class="task-description">${task.description}</div>
                                    `;

                                    // Add deadline for non-completed tasks
                                    if (!task.completed) {
                                        taskInnerHtml += `<div><span style="font-weight: bold;">Deadline:</span> ${task.deadline}</div>`;
                                    }

                                    // Add progress reports for completed tasks
                                    if (task.completed && task.progress_reports) {
                                        let reportsHtml = `
                                            <div style="margin-top: 8px;"><strong>Progress Reports:</strong>
                                                <ul style="margin-top: 5px;">
                                        `;
                                        for (const reportId in task.progress_reports) {
                                            const report = task.progress_reports[reportId];
                                            reportsHtml += `
                                                <li style="margin-bottom: 5px;">
                                                    - ${report.progress} by ${report.submitted_by}
                                                    ${report.file ? `<a href="/download_file/${groupId}/${task.task_id}/${report.submitted_by}/${report.file}" target="_blank" style="text-decoration: underline; margin-left: 5px;">Download</a>` : ''}
                                                </li>
                                            `;
                                        }
                                        reportsHtml += `
                                                </ul>
                                            </div>
                                        `;
                                        taskInnerHtml += reportsHtml;
                                    } else if (task.completed && !task.progress_reports) {
                                        taskInnerHtml += `<div><em>No progress reports yet</em></div>`;
                                    }

                                    // Add submit progress form for non-completed tasks
                                    if (!task.completed && (task.assigned_to === username || task.assigned_type === 'everyone')) {
                                        taskInnerHtml += `
                                            <form action="/submit_progress/${username}/${groupId}/${task.task_id}" method="POST" enctype="multipart/form-data" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
                                                <div style="margin-bottom: 8px;"><input type="text" name="progress" placeholder="Progress update..." required style="width: 100%;"></div>
                                                <div style="margin-bottom: 8px;"><input type="file" name="file"></div>
                                                <button type="submit">Submit Progress</button>
                                            </form>
                                        `;
                                    }
                                    
                                    taskElement.innerHTML = taskInnerHtml;
                                    container.appendChild(taskElement);
                                });
                            }

                            // Re-attach event listeners for collapsible sections
                            document.querySelectorAll('.collapsible').forEach(el => {
                                if (!el.dataset.listenerAdded) {
                                    el.addEventListener('click', () => toggleCollapsible(el));
                                    el.dataset.listenerAdded = 'true';
                                }
                            });
                        };

                        // Render each task category
                        renderTasks('done-tasks', completed_tasks, 'No completed tasks');
                        renderTasks('this-week-tasks', tasks_this_week, 'No tasks for this week');
                        renderTasks('next-week-tasks', tasks_next_week, 'No tasks for next week');

                    } else {
                        console.error('Failed to fetch tasks:', data.message);
                    }
                })
                .catch(error => console.error('Error fetching tasks:', error));
        }

        // Set up the interface when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Initial fetch of tasks and messages
            fetchMessages();
            fetchTasks(); 
            
            // Refresh tasks and messages every 10 seconds
            setInterval(fetchMessages, 10000);
            setInterval(fetchTasks, 10000); 

            // Add event listeners for UI buttons
            document.getElementById('whiteboardToggleBtn').addEventListener('click', openWhiteboard);
            document.getElementById('closeWhiteboardBtn').addEventListener('click', closeWhiteboard);
            document.getElementById('clearWhiteboardBtn').addEventListener('click', clearWhiteboard);
            document.getElementById('taskPanelToggle').addEventListener('click', toggleTaskPanel);
            document.getElementById('joinBtn').addEventListener('click', joinVoiceCall);
            document.getElementById('leaveBtn').addEventListener('click', leaveVoiceCall);

            // Set up collapsible sections initially
            document.querySelectorAll('.collapsible').forEach(el => {
                el.addEventListener('click', () => toggleCollapsible(el));
            });
        });
    </script>
</body>
</html>
